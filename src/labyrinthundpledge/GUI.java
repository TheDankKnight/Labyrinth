/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labyrinthundpledge;

import java.awt.Graphics;
import java.awt.Color;
import java.util.ArrayList;
import java.awt.image.BufferedImage;
import java.awt.Graphics2D;
import java.awt.event.*;
import java.awt.geom.AffineTransform;
/**
 *
 * @author Ich
 */
class Position{
    int x,y;
    Position(){
        
    }
    Position(int x, int y){
        this.x = x;
        this.y = y;
    }
}

public class GUI extends javax.swing.JFrame implements MouseListener{
    int width=8, height=8;
    int panelW, panelH, absPanelW, absPanelH, drawOffX, drawOffY;
    int feldW, feldH;
    Color bgColor, wallColor = new Color(0,0,0), delColor = new Color(255,0,0), playerColor, playerTraceColor;
    Kruskal gen;
    Mauer[] borderN, borderE, borderS, borderW;
    Kasten[][] kasten;
    ArrayList<Mauer> borderMauern, festeMauern;
    BufferedImage backBuffer;
    boolean stop=false;
    boolean genOnlyDrawEnd=false;
    
    Player player;
    boolean spielerSetzen = false;
    boolean walls[][][];
    BufferedImage playerImage[];
    ArrayList<Position> playerTrace = new ArrayList();
    
    int pledgeRunDelay;
    /**
     * Creates new form GUI
     */
    public GUI() {
        addMouseListener(this);
        initComponents();
        absPanelW = drawingPanel.getWidth();
        absPanelH = drawingPanel.getHeight();
        bgColor = drawingPanel.getBackground();
        recalcProportions();
        slPledgeRunDelay.setMinimum(0);
        slPledgeRunDelay.setMaximum(500); // 1s
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        options = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        tfWidth = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        tfHeight = new javax.swing.JTextField();
        generierenOptions = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        btRunGenerator = new javax.swing.JButton();
        btStepGenerator = new javax.swing.JButton();
        cbGenRunDraw = new javax.swing.JCheckBox();
        btOK = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        tgDavisSetzen = new javax.swing.JToggleButton();
        btRunPledge = new javax.swing.JButton();
        btStepPledge = new javax.swing.JButton();
        slPledgeRunDelay = new javax.swing.JSlider();
        jLabel5 = new javax.swing.JLabel();
        btResetField = new javax.swing.JButton();
        drawingPanel = new javax.swing.JPanel();

        jButton1.setText("jButton1");

        jButton2.setText("Step");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        options.setBackground(new java.awt.Color(210, 210, 210));

        jLabel2.setText("Breite: ");

        tfWidth.setText("8");

        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        jLabel3.setText("Höhe: ");

        tfHeight.setText("8");

        generierenOptions.setBackground(new java.awt.Color(190, 190, 190));
        generierenOptions.setToolTipText("");

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(73, 105, 121));
        jLabel4.setText("Generieren:");

        btRunGenerator.setText("Run");
        btRunGenerator.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btRunGeneratorActionPerformed(evt);
            }
        });

        btStepGenerator.setText("Step");
        btStepGenerator.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btStepGeneratorActionPerformed(evt);
            }
        });

        cbGenRunDraw.setBackground(new java.awt.Color(190, 190, 190));
        cbGenRunDraw.setText("nur Ende malen");
        cbGenRunDraw.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cbGenRunDrawActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout generierenOptionsLayout = new javax.swing.GroupLayout(generierenOptions);
        generierenOptions.setLayout(generierenOptionsLayout);
        generierenOptionsLayout.setHorizontalGroup(
            generierenOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(generierenOptionsLayout.createSequentialGroup()
                .addGroup(generierenOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(generierenOptionsLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(generierenOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(btRunGenerator, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btStepGenerator, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(cbGenRunDraw, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addContainerGap())
        );
        generierenOptionsLayout.setVerticalGroup(
            generierenOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(generierenOptionsLayout.createSequentialGroup()
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btRunGenerator)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(cbGenRunDraw)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btStepGenerator)
                .addGap(0, 10, Short.MAX_VALUE))
        );

        btOK.setText("OK");
        btOK.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btOKActionPerformed(evt);
            }
        });

        jPanel1.setBackground(new java.awt.Color(190, 190, 190));

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(73, 105, 121));
        jLabel1.setText("Lösen:");

        tgDavisSetzen.setText("Spieler Setzen");
        tgDavisSetzen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                tgSpielerSetzen(evt);
            }
        });

        btRunPledge.setText("Run");
        btRunPledge.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btRunPledgeActionPerformed(evt);
            }
        });

        btStepPledge.setText("Step");
        btStepPledge.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btStepPledgeActionPerformed(evt);
            }
        });

        slPledgeRunDelay.setBackground(new java.awt.Color(190, 190, 190));
        slPledgeRunDelay.setForeground(new java.awt.Color(160, 160, 160));
        slPledgeRunDelay.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                slPledgeRunDelayMouseDragged(evt);
            }
        });

        jLabel5.setText("delay:");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jLabel1)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(tgDavisSetzen, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btRunPledge, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btStepPledge, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(slPledgeRunDelay, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(tgDavisSetzen)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btRunPledge)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(slPledgeRunDelay, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btStepPledge)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        btResetField.setText("Reset");
        btResetField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btResetFieldActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout optionsLayout = new javax.swing.GroupLayout(options);
        options.setLayout(optionsLayout);
        optionsLayout.setHorizontalGroup(
            optionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(optionsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(optionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(generierenOptions, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(optionsLayout.createSequentialGroup()
                        .addGroup(optionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(optionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(tfHeight, javax.swing.GroupLayout.DEFAULT_SIZE, 43, Short.MAX_VALUE)
                            .addComponent(tfWidth)))
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, optionsLayout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addGroup(optionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(btResetField, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btOK, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())))
        );
        optionsLayout.setVerticalGroup(
            optionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(optionsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(optionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(tfWidth, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(optionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(tfHeight, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btOK)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(btResetField)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(generierenOptions, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        drawingPanel.setBackground(new java.awt.Color(255, 255, 255));
        drawingPanel.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                drawingPanelComponentResized(evt);
            }
        });

        javax.swing.GroupLayout drawingPanelLayout = new javax.swing.GroupLayout(drawingPanel);
        drawingPanel.setLayout(drawingPanelLayout);
        drawingPanelLayout.setHorizontalGroup(
            drawingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 525, Short.MAX_VALUE)
        );
        drawingPanelLayout.setVerticalGroup(
            drawingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 527, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(options, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(drawingPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(drawingPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(options, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void deleteMauer(Mauer m){
        Graphics g = drawingPanel.getGraphics();
        g.setColor(delColor);
        if(m.getOrientation()==Mauer.richtungen.horizontal){
            g.drawLine(drawOffX+m.xpos*feldW, drawOffY+m.ypos*feldH, drawOffX+(m.xpos+1)*feldW, drawOffY+m.ypos*feldH);
        } else {
            g.drawLine(drawOffX+m.xpos*feldW, drawOffY+m.ypos*feldH, drawOffX+m.xpos*feldW, drawOffY+(m.ypos+1)*feldH);
        }
        redraw();
    }
    
    private void btRunGeneratorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btRunGeneratorActionPerformed
        while(!gen.finished() && !stop){
            if(genOnlyDrawEnd){
                gen.step();
            } else {
                deleteMauer(gen.step());
            }
        }
        bakeWalls();
        recalcPlayerColor();
        redraw();
    }//GEN-LAST:event_btRunGeneratorActionPerformed

    private void btStepGeneratorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btStepGeneratorActionPerformed
        if(gen.finished()){
            recalcPlayerColor();
            bakeWalls();
        } else {
            deleteMauer(gen.step());
        }
    }//GEN-LAST:event_btStepGeneratorActionPerformed

    private void btOKActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btOKActionPerformed
        width = Integer.parseInt(tfWidth.getText());
        height = Integer.parseInt(tfHeight.getText());
        recalcProportions();
        btResetFieldActionPerformed(null);
    }//GEN-LAST:event_btOKActionPerformed

    private void drawingPanelComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_drawingPanelComponentResized
        absPanelW = drawingPanel.getWidth();
        absPanelH = drawingPanel.getHeight();  
        recalcProportions();
        try{
            redraw();
        } catch(Exception e){
            
        }
    }//GEN-LAST:event_drawingPanelComponentResized

    private void btResetFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btResetFieldActionPerformed
        if(gen != null)
            gen.cleanup();
        gen = new Kruskal(width, height);
        borderMauern = gen.borderMauern;
        festeMauern = gen.festeMauern;
        borderN = gen.borderN;
        borderE = gen.borderE;
        borderS = gen.borderS;
        borderW=gen.borderW;
        kasten = gen.getKasten();
        walls = null;
        player = null;
        playerTrace.clear();
        redraw();
    }//GEN-LAST:event_btResetFieldActionPerformed

    private void cbGenRunDrawActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cbGenRunDrawActionPerformed
        genOnlyDrawEnd = cbGenRunDraw.isSelected();
    }//GEN-LAST:event_cbGenRunDrawActionPerformed

    private void tgSpielerSetzen(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_tgSpielerSetzen
        spielerSetzen = tgDavisSetzen.isSelected();
    }//GEN-LAST:event_tgSpielerSetzen

    private void btRunPledgeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btRunPledgeActionPerformed
        if(player == null)
            return;
        while(player.getX() < width && player.getY() < height){
            player.step();
            playerTrace.add(new Position(player.getX(), player.getY()));
            try{
                Thread.sleep(pledgeRunDelay);
            } catch (Exception e){
                e.printStackTrace();
            }
            redraw();
        }
    }//GEN-LAST:event_btRunPledgeActionPerformed

    private void btStepPledgeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btStepPledgeActionPerformed
        if(player==null)
            return;
        if(player.getX() < width && player.getY() < height){
            player.step();
            playerTrace.add(new Position(player.getX(), player.getY()));
        } else
            System.err.println("DONE!");
        redraw();
    }//GEN-LAST:event_btStepPledgeActionPerformed

    private void slPledgeRunDelayMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_slPledgeRunDelayMouseDragged
        pledgeRunDelay = slPledgeRunDelay.getValue();
    }//GEN-LAST:event_slPledgeRunDelayMouseDragged
    
    private void bakeWalls(){
        walls = new boolean[width][height][4];
        int s = borderMauern.size();
        Mauer cur;
        for(int i=0; i<s; ++i){
            cur = borderMauern.get(i);
            if(cur.getOrientation() == Mauer.richtungen.horizontal){
                if(cur.ypos > 0)
                    walls[cur.xpos][cur.ypos-1][Player.S] = true;
                walls[cur.xpos][cur.ypos][Player.N] = true;
            } else {
                if(cur.xpos > 0)
                    walls[cur.xpos-1][cur.ypos][Player.E] = true;
                walls[cur.xpos][cur.ypos][Player.W] = true;
            }
        }
        s = festeMauern.size();
        for(int i=0; i<s; ++i){
            cur = festeMauern.get(i);
            if(cur.getOrientation() == Mauer.richtungen.horizontal){
                if(cur.ypos > 0)
                    walls[cur.xpos][cur.ypos-1][Player.S] = true;
                walls[cur.xpos][cur.ypos][Player.N] = true;
            } else {
                if(cur.xpos > 0)
                    walls[cur.xpos-1][cur.ypos][Player.E] = true;
                walls[cur.xpos][cur.ypos][Player.W] = true;
            }
        }
        // Ränder in's Array schreiben:
        for(int x=0; x<width; ++x){
            walls[x][0][Player.N] = true;
            walls[x][height-1][Player.S] = true;
        }
        for(int y=0; y<height; ++y){
            walls[0][y][Player.W] = true;
            walls[width-1][y][Player.E] = true;
        }
        walls[width-1][height-1][Player.E] = false; 
    }
    
    private void recalcProportions(){
        backBuffer = new BufferedImage(absPanelW, absPanelH, BufferedImage.TYPE_INT_RGB);
        if(absPanelW/width > absPanelH/height){ // Breitbild: x-Abstand
            int temp = (absPanelH*width/height); // Verhältniss von width und height beibehalen
            panelW = temp;
            panelH = absPanelH;
            drawOffX = (absPanelW-temp)/2;
            drawOffY = 0;
        } else { // Hochkant: <-Abstand
            int temp = (absPanelW*height/width); // Verhältniss von width und height beibehalen
            panelW = absPanelW;
            panelH = temp;
            drawOffX = 0;
            drawOffY = (absPanelH-temp)/2;
        }
        feldW = panelW/width;
        feldH = panelH/height;
        recalcPlayer();
    }
    
    @Override
    public void mouseClicked(MouseEvent e) {
        System.err.println("Mouse clicked: " + spielerSetzen);
        if(walls != null){
            if(spielerSetzen){
                int x = calcXInMaze(e.getX());
                int y = calcYInMaze(e.getY());
                if( x >= 0 && x < width && y >= 0 && y < height){
                    System.err.println("setPayer at (" + x + "|" + y + ")");
                    if(x<=width && y<=height){
                        Player temp = player;
                        player = new Player(x, y, walls);
                        playerTrace.clear();
                        playerTrace.add(new Position(player.getX(), player.getY()));
                        if(temp == null)
                            recalcPlayer();
                    }
                    redraw();
                }
            }
        }
    }

    @Override
    public void mousePressed(MouseEvent e) {
        System.err.println("Mouse pressed");
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        System.err.println("Mouser released");
    }

    private int calcXInMaze(int xOnScreen){
        int xOff = drawingPanel.getX();
        xOnScreen -= xOff;
        
        xOnScreen -= drawOffX;
        // Alle Ränder wurden jetzt berücksichtigt
        if(xOnScreen<0)
            System.err.println("calcXInMaze gibt wert kleiner als 0 zurück: " + xOnScreen/width);
        return xOnScreen/feldW;
    }
    
    private int calcYInMaze(int yOnScreen){
        int yOff = drawingPanel.getY();
        yOnScreen -= yOff -drawOffY + feldH/2;
        // Alle Ränder wurden jetzt berücksichtigt
        if(yOnScreen<0)
            System.err.println("calcYInMaze gibt wert kleiner als 0 zurück: " + yOnScreen/height);
        return yOnScreen/feldH;
    }
    
    @Override
    public void mouseEntered(MouseEvent e) {
        
    }

    @Override
    public void mouseExited(MouseEvent e) {
        
    }
    
    private void redraw(){
        // Init      
        Graphics2D g = backBuffer.createGraphics();
        g.setColor(bgColor);
        g.fillRect(0, 0, absPanelW, absPanelH);
        
        // Regionen
        for(int x=0; x<width; ++x){
            for(int y=0; y<height; ++y){
                g.setColor(kasten[x][y].feld.color);
                g.fillRect(drawOffX+kasten[x][y].x*feldW, drawOffY+kasten[x][y].y*feldH, feldW, feldH);
            }
        }
        
        // Wände
        if(walls == null)
            drawDynamicWalls(g);
        else
            drawStaticWalls(g);
        
        
        drawPlayer(g);
        
        drawingPanel.getGraphics().drawImage(backBuffer, 0, 0, null);
    }
    
    public void drawDynamicWalls(Graphics2D g){
        g.setColor(wallColor);
        int size = borderMauern.size();
        Mauer cur;
        for(int i=0; i<size; ++i){
            cur = borderMauern.get(i);
            if(cur.getOrientation()==Mauer.richtungen.horizontal){
                g.drawLine(drawOffX+cur.xpos*feldW, drawOffY+cur.ypos*feldH, drawOffX+(cur.xpos+1)*feldW, drawOffY+cur.ypos*feldH);
            } else {
                g.drawLine(drawOffX+cur.xpos*feldW, drawOffY+cur.ypos*feldH, drawOffX+cur.xpos*feldW, drawOffY+(cur.ypos+1)*feldH);
            }
        }      
        for(int x=0; x<width; ++x){
            g.drawLine(drawOffX+borderN[x].xpos*feldW, drawOffY+borderN[x].ypos*feldH, drawOffX+(borderN[x].xpos+1)*feldW, drawOffY+borderN[x].ypos*feldH);
            g.drawLine(drawOffX+borderS[x].xpos*feldW, drawOffY+borderS[x].ypos*feldH, drawOffX+(borderS[x].xpos+1)*feldW, drawOffY+borderS[x].ypos*feldH);
        }
        for(int y=0; y<height; ++y){
            g.drawLine(drawOffX+borderE[y].xpos*feldW, drawOffY+borderE[y].ypos*feldH, drawOffX+borderE[y].xpos*feldW, drawOffY+(borderE[y].ypos+1)*feldH);
            g.drawLine(drawOffX+borderW[y].xpos*feldW, drawOffY+borderW[y].ypos*feldH, drawOffX+borderW[y].xpos*feldW, drawOffY+(borderW[y].ypos+1)*feldH);
        }
        // feste Wände
        size = festeMauern.size();
        //g.setStroke(new BasicStroke(3));
        for(int i=0; i<size; ++i){
            cur = festeMauern.get(i);
            /*try{
                Thread.sleep(10); // warum auch immer aber sonst funktioniert's nicht.
            } catch (Exception e){
                e.printStackTrace();
            }*/
            if(cur.getOrientation()==Mauer.richtungen.horizontal){
                g.drawLine(drawOffX+cur.xpos*feldW, drawOffY+cur.ypos*feldH, drawOffX+(cur.xpos+1)*feldW, drawOffY+cur.ypos*feldH);
            } else {
                g.drawLine(drawOffX+cur.xpos*feldW, drawOffY+cur.ypos*feldH, drawOffX+cur.xpos*feldW, drawOffY+(cur.ypos+1)*feldH);
            }
        } 
    }
    
    public void drawStaticWalls(Graphics2D g){
        System.err.println("Drawing stati walls");
        g.setColor(wallColor);
        for(int x=0; x<width; ++x){
            for(int y=0; y<height; ++y){
                if(walls[x][y][Player.N])
                    g.drawLine(drawOffX+x*feldW, drawOffY+y*feldH, drawOffX+(x+1)*feldW, drawOffY+y*feldH);
                if(walls[x][y][Player.E])
                    g.drawLine(drawOffX+(x+1)*feldW, drawOffY+y*feldH, drawOffX+(x+1)*feldW, drawOffY+(y+1)*feldH);
                if(walls[x][y][Player.S])
                    g.drawLine(drawOffX+x*feldW, drawOffY+(y+1)*feldH, drawOffX+(x+1)*feldW, drawOffY+(y+1)*feldH);
                if(walls[x][y][Player.W])
                    g.drawLine(drawOffX+x*feldW, drawOffY+y*feldH, drawOffX+x*feldW, drawOffY+(y+1)*feldH);
            }
        }
    }
    
    public void recalcPlayer(){
        if(player == null)
            return;
        playerImage = new BufferedImage[4];
        for(int i=0; i<4; ++i)
            playerImage[i] = new BufferedImage(feldW, feldH, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g  = playerImage[0].createGraphics();
        g.setColor(playerColor);
        int triangleX[] = new int[3], triangleY[] = new int[3];
        triangleX[0] = feldW/2;
        triangleY[0] = (feldH/5);
        triangleX[1] = (int)(feldW*0.8f);
        triangleY[1] = feldH-triangleY[0];
        triangleX[2] = (int)(feldW*0.2f);
        triangleY[2] = feldH-triangleY[0];
        
        g.fillPolygon(triangleX, triangleY, 3);
        
        AffineTransform trans;
        for(int i=1; i<4; ++i){
            trans = AffineTransform.getRotateInstance(i*Math.PI/2, feldW/2, feldH/2);
            g = playerImage[i].createGraphics();
            g.drawImage(playerImage[0], trans, null);
        }
        
    }
    
    public void recalcPlayerColor(){
        Color col = kasten[0][0].feld.color;
        int r = col.getRed();
        int g = col.getGreen();
        int b = col.getBlue();
        playerColor = new Color(r/2, g/2, b/2);
        playerTraceColor = new Color(Math.min(255, 2*r/3),Math.min(255, 2*g/3),Math.min(255, 2*b/3));
    }
    
    public void drawPlayer(Graphics2D g){
        if(player == null)
            return;
        System.err.println("Player: " + player);
        //Spieler Spuren malen
        if(playerTrace.isEmpty()){
            System.err.println("PlayerTrace leer obwohl player existiert.");
            return;
        }
        int s = playerTrace.size();
        Position last = playerTrace.get(0);
        Position cur;
        g.setColor(playerTraceColor);
        for(int i=1; i<s; ++i){
            cur = playerTrace.get(i);
            g.drawLine(drawOffX + feldW*last.x+feldW/2, drawOffY + feldH*last.y+feldH/2, drawOffX + feldW*cur.x+feldW/2, drawOffY + feldH*cur.y+feldH/2);
            last = cur;
        }

        //Spieler malen
        g.drawImage(playerImage[player.getOrientation()], drawOffX + feldW*player.getX(), drawOffY + feldH*player.getY(), null);
        //g.fillRect(drawOffX + feldW*player.getX()+(int)(0.1f*feldW), drawOffY + feldH*player.getY()+(int)(0.1f*feldH), (int)(0.8f*feldW), (int)(0.8f*feldH));
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btOK;
    private javax.swing.JButton btResetField;
    private javax.swing.JButton btRunGenerator;
    private javax.swing.JButton btRunPledge;
    private javax.swing.JButton btStepGenerator;
    private javax.swing.JButton btStepPledge;
    private javax.swing.JCheckBox cbGenRunDraw;
    private javax.swing.JPanel drawingPanel;
    private javax.swing.JPanel generierenOptions;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel options;
    private javax.swing.JSlider slPledgeRunDelay;
    private javax.swing.JTextField tfHeight;
    private javax.swing.JTextField tfWidth;
    private javax.swing.JToggleButton tgDavisSetzen;
    // End of variables declaration//GEN-END:variables

}
